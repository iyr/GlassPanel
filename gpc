#!/bin/bash

#Vanilla Console Resolution is 80 Columns by 22 Rows (mostly).

#Detect Initial Setup
USER=$(whoami)
PACKAGE_MANAGER="YUM"

MOTD="/tmp/.tmpmotd_$USER"

#Remove temporary motd, if one already exists.
if [ -f "$MOTD" ]
	then
	rm $MOTD
fi

if [ $USER = "root" ]
	then
		if [ -f "/root/.gpc_settings" ]
		then
			echo -e "Generic settings file found, configuring for root."
			mv /root/.gpc_settings /root/.gpc_settings_root
			SETTINGS="/root/.gpc_settings_root"
		else
			SETTINGS="/root/.gpc_settings_root"
		fi
	else
		if [ -f "/home/$USER/.gpc_settings" ]
		then
			echo -e "Generic settings file found, configuring for $USER \b."
			mv /home/$USER/.gpc_settings /home/$USER/.gpc_settings_$USER
			SETTINGS="/home/$USER/.gpc_settings_$USER"
		else
			SETTINGS="/home/$USER/.gpc_settings_$USER"
		fi
fi

if [ -f "$SETTINGS" ]
	then
		echo -e "Configuration file detected for $USER!"
		echo -e "Reading settings..."
	else
		echo -e "No configuration file found!"
		echo -e "Detecting system..."
		echo -e "Appending $USER's bash profile..."
		if [ $USER = "root" ]
			then
				sed -i '/cat \/tmp\/.tmpmotd_root/d' /root/.bash_profile
				echo -e "cat $MOTD" >> /root/.bash_profile
			else
				sed -i "/cat \/tmp\/.tmpmotd_$USER/d" /home/$USER/.bash_profile
				echo -e "cat $MOTD" >> /home/$USER/.bash_profile
		fi

		#Add GlassPanel to user's crontab
		#Method barrowed from http://stackoverflow.com/questions/878600
		crontab -l > tmpcron
		echo -e "*/30 * * * * /home/$USER/gpc" >> tmpcron
		crontab tmpcron
		rm tmpcron

		echo -e "Generating settings file for $USER \b..."		
		#Generate Tweakable Settings file
		echo -e "USER=$USER" >> $SETTINGS
		echo -e "#Insert a custom static header to the Glass Panel, if desired:" >> $SETTINGS
		echo -e "HEADER=" >> $SETTINGS
		echo -e "#Append a custom static footer to the Glass Panel, if desired:" >> $SETTINGS
		echo -e "FOOTER=" >> $SETTINGS
		echo -e "#Adjust settings for color coding; below moderate is green, below critical is yellow and above is red" >> $SETTINGS
		echo -e "#Memory Settings:" >> $SETTINGS
		echo -e "MODERATE_MEM=60" >> $SETTINGS
		echo -e "CRITICAL_MEM=80" >> $SETTINGS
		echo -e "#CPU Settings:" >> $SETTINGS
		echo -e "MODERATE_CPU=60" >> $SETTINGS
		echo -e "CRITICAL_CPU=80" >> $SETTINGS
		echo -e "#Allows you to append the status of selected services to the motd (none enabled by default)" >> $SETTINGS
		echo -e "#Usage: SERVICE \"ServiceName\" \"ServiceAlias\" (no spaces in alias)" >> $SETTINGS
		echo -e "#Example: SERVICE NetworkManager Networking" >> $SETTINGS
		echo -e "#Environment Settings, do not edit." >> $SETTINGS
fi


#Print the status of a service:
NM_STATUS=$(service NetworkManager status | awk 'NR == 3 {print $2}')
if [ $NM_STATUS = "active" ]
	then
	echo -e "[ \e[0;32mNetworking\e[0m ]" >> $MOTD
	else
	echo -e "[ \e[0;31mNetworking\e[0m ]" >> $MOTD
fi

#Detect Internet availability:
GOOGLE_STATUS=$(ping -c4 google.com | awk 'NR == 8 {print $6}' | cut -c1)
if [ $GOOGLE_STATUS -eq 0 ]
	then
	INT_STATUS="true"
	INT_COL="\e[0;32mINT\e[0m"
	elif [ $GOOGLE_STATUS -gt 0  ]
		then
		INT_STATUS="false"
		INT_COL="\e[1;33mINT\e[0m"
	else
	INT_STATUS="false"
	INT_COL="\e[0;31mINT\e[0m"
fi
echo -e "[ $INT_COL ]" >> $MOTD

#Calculates the system memory usage as a rounded integer percentage and prints to a log
CUR_MEM=$(free | awk 'NR == 3 {print $3} NR == 2 {print $2}' | paste -sd" " | awk 'NR ==1 {print $2/$1*100}' | awk '{printf("%d\n",$1 + 0.5)}')
if [ $CUR_MEM -lt 60 ]
	then
	CUR_MEM_COL="\e[0;32m"
	elif [ $CUR_MEM -ge 60 -a $CUR_MEM -lt 80 ]
	then
	CUR_MEM_COL="\e[1;33m"
	else
	CUR_MEM_COL="\e0;31m"
fi
echo -e "[ $CUR_MEM_COL \bRAM\e[0m ][ $CUR_MEM_COL \b%$CUR_MEM\e[0m memory in use ]" >> $MOTD

CUR_CPU=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print $1}' | awk '{printf("%d\n",$1 + 0.5)}')
#Possibly the least elegant way to calculate average cpu usage and normalize to cpu core count:
AVE_CPU=$(echo -e "$(echo -e "($(uptime | cut -d" " -f14) / $(cat /proc/cpuinfo | grep -c "processor")) * 100" | bc -l) / 1 " | bc)
if [ $CUR_CPU -lt 60 ] && [ $AVE_CPU -lt 60 ]
        then
	CPU_COL="\e[0;32m"
        elif [ $CUR_CPU -ge 60 -a $CUR_CPU -lt 80 ] && [ $AVE_CPU -ge 60 -o $AVE_CPU -lt 80 ]
        then
	CPU_COL="\e[1;33m"
        else
	CPU_COL="\e[0;31m"
fi
	
echo -e "[ $CPU_COL \bCPU\e[0m ][ $CPU_COL \b%$CUR_CPU\e[0m CPU in use, $CPU_COL%$AVE_CPU\e[0m ave 15m ]" >> $MOTD

#Determine how many (if any) updates are available.
if [ $INT_STATUS = "false" ]
	then
	echo -e "[ \e[0;31m$PACKAGE_MANAGER\e[0m ][ No connection to internet ]" >> $MOTD
	else
		yum check-update > .gplog
		if [ $? -ne 0 ]
		then
		echo -e "[ \e0;31m$PACKAGE_MANAGER\e[0m ][ $PACKAGE_MANAGER exited with error code $? ]" >> $MOTD
		else
		NUM_UPDATES=$(grep -c "updates" .gplog)
		fi
			if [ $NUM_UPDATES -ne 0 ]
				then
				echo -e "[ \e[1;33m$PACKAGE_MANAGER\e[0m ][ $NUM_UPDATES update(s) available ]" >> $MOTD
				else
				echo -e "[ \e[0;32m$PACKAGE_MANAGER\e[0m ][ $NUM_UPDATES updates available, System is up to date ]" >> $MOTD
			fi
fi

#Determine status of SELinux and display how many (if any) alerts there are:
#enforcing 	= green
#permissive 	= yellow
#disabled 	= red
SEL_STATUS=$(sestatus | awk 'NR == 5 {print $3}')
SEL_ALERTS=$(sealert -l* | grep -c "denied") 
if [ $SEL_ALERTS -eq 0 ]
	then
	SEL_ALERT_COL="\e[0;32m"
	else
	SEL_ALERT_COL="\e[0;31m"
fi

if [ $SEL_STATUS = "enforcing" ]
	then
	echo -e "[ \e[0;32mSEL\e[0m ][ $SEL_ALERT_COL$SEL_ALERTS alert(s)\e[0m ]" >> $MOTD
	elif [ $SEL_STATUS = "permissive" ]
		then
		echo -e "[ \e[1;33mSEL\e[0m ][ $SEL_ALERT_COL$SEL_ALERTS alert(s)\e[0m ]" >> $MOTD
	else
	echo -e "[ \e[0;31mSEL\e[0m ][ $SEL_ALERT_COL$SEL_ALERTS alert(s)\e[0m ]" >> $MOTD
fi

cat $MOTD
exit 0
