#!/bin/bash

#Vanilla Console Resolution is 80 Columns by 22 Rows (mostly).

#Detect Initial Setup
USER=$(whoami)
MOTD="/tmp/.tmpmotd_$USER"

#Calculate the amount of time that has elapsed since the last execution of the script
if [ -e "$MOTD" ]
	then
	LAST_EXEC=$(echo -e "$(date | awk '{print $4}' | cut -d ':' -f2) - $(cat /tmp/.tmpmotd_$USER | awk 'NR == 1 {print $7}' | cut -d ':' -f2)" | bc)
	else
	LAST_EXEC=31
fi

#Remove temporary motd, if one already exists.
if [ -f "$MOTD" ]
	then
	rm $MOTD
fi

if [ $USER = "root" ]
	then
		if [ -f "/root/.gpc_settings" ]
		then
			echo -e "Generic settings file found, configuring for root."
			mv /root/.gpc_settings /root/.gpc_settings_root
			SETTINGS="/root/.gpc_settings_root"
		else
			SETTINGS="/root/.gpc_settings_root"
		fi
	else
		if [ -f "/home/$USER/.gpc_settings" ]
		then
			echo -e "Generic settings file found, configuring for $USER \b."
			mv /home/$USER/.gpc_settings /home/$USER/.gpc_settings_$USER
			SETTINGS="/home/$USER/.gpc_settings_$USER"
		else
			SETTINGS="/home/$USER/.gpc_settings_$USER"
		fi
fi

if [ -f "$SETTINGS" ]
	then
		echo -e "Configuration file detected for $USER!"
		echo -e "Reading settings..."
		awk 'NR >= 0 && NR <= 20' $SETTINGS > /home/$USER/.gpart
		source /home/$USER/.gpart
		rm /home/$USER/.gpart
	else
		echo -e "No configuration file found!"
		echo -e "Detecting system..."
		echo -e "Appending $USER's bash profile..."
		if [ $USER = "root" ]
			then
				sed -i '/cat \/tmp\/.tmpmotd_root/d' /root/.bash_profile
				echo -e "cat $MOTD" >> /root/.bash_profile
			else
				sed -i "/cat \/tmp\/.tmpmotd_$USER/d" /home/$USER/.bash_profile
				echo -e "cat $MOTD" >> /home/$USER/.bash_profile
		fi

		#Determine if System is using systemd or sysvinit
		if [ $(pidof systemd) -eq 1 ]
			then
			ENV=systemd
		elif [ $(pidof sysvinit) -eq 1 ]
			then
			ENV=sysv
			else
			echo "System not supported, halting"
			exit 1
		fi

		#Check for dependencies
		#Check if crond is running
		if [ "$ENV" = "systemd" ]
		then
			if [ "$(systemctl status crond | grep -q "active (running)" && echo $?)" -ne "0" ]
			then
				echo "Cron is not running, GlassPanel needs Cron to function. Halting"
				exit 1
			fi
		else
			if [ "$(service crond status | grep -q "active (running)" && echo $?)" -ne "0" ]
			then
				echo "Cron is not running, GlassPanel needs Cron to function. Halting"
				exit 1
			fi
		fi

		#Check if bc is installed
		if [ -e "/usr/bin/bc" ]
			then
				echo "bc detected, proceeding"
			else
				echo "bc not installed, GlassPanel needs bc to function. Halting"
				exit 1
		fi

		#Add GlassPanel to user's crontab
		#Method barrowed from http://stackoverflow.com/questions/878600
		crontab -l > tmpcron
		if [ $USER = "root" ]
			then
				echo -e "*/30 * * * * /root/gpc" >> tmpcron
			else
				echo -e "*/30 * * * * /home/$USER/gpc" >> tmpcron
		fi
		crontab tmpcron
		rm tmpcron

		echo -e "Generating settings file for $USER \b..."		
		#Generate Tweakable Settings file
		echo -e "ENV=$ENV" >> $SETTINGS
		echo -e "USER=$USER" >> $SETTINGS
		echo -e "#Insert a custom static header to the Glass Panel, if desired:" >> $SETTINGS
		echo -e "HEADER=" >> $SETTINGS
		echo -e "#Append a custom static footer to the Glass Panel, if desired:" >> $SETTINGS
		echo -e "FOOTER=" >> $SETTINGS
		echo -e "#Decide what default aspects of the system GlassPanel should monitor and display:" >> $SETTINGS
		echo -e "INTERNET=true" >> $SETTINGS
		echo -e "MEMORY=true" >> $SETTINGS
		echo -e "CPU=true" >> $SETTINGS
		echo -e "DISK=true" >> $SETTINGS
		echo -e "#Allows you to append the status of selected services to the motd (none enabled by default)" >> $SETTINGS
		echo -e "#Usage: SERVICE \"ServiceName\" \"ServiceAlias\" (no spaces in alias)" >> $SETTINGS
		echo -e "#Example: SERVICE NetworkManager Networking" >> $SETTINGS
		echo -e "#Allows you to append the status of selected websites to the motd (none enabled by default)" >> $SETTINGS
		echo -e "#Usage: WEBSITE \"URL\" \"WebsiteAlias\" (no spaces in alias)" >> $SETTINGS
		echo -e "#Example: WEBSITE google.com Google" >> $SETTINGS
		echo -e "#Environment Settings, do not edit." >> $SETTINGS
fi

#Print the status of a service:
#NM_STATUS=$(service NetworkManager status | awk 'NR == 3 {print $2}')
#if [ $NM_STATUS = "active" ]
#	then
#	echo -e "[ \e[0;32mNetworking\e[0m ]" >> $MOTD
#	else
#	echo -e "[ \e[0;31mNetworking\e[0m ]" >> $MOTD
#fi

#Determine status of SELinux and display overall system information.
#enforcing 	= green
#permissive 	= yellow
#disabled 	= red
SEL_STATUS=$(sestatus | awk 'NR == 5 {print $3}')
	if [ $SEL_STATUS = "enforcing" ]
		then
		echo -e "[ \e[0;32mSYS\e[0m ][ $(date) \e[0;32m-\e[0m Uptime: $(uptime | awk '{print $3}') \e[0;32m-\e[0m $HOSTNAME \e[0;32m-\e[0m \e[0;32mSEL\e[0m ]" >> $MOTD
	elif [ $SEL_STATUS = "permissive" ]
		then
		echo -e "[ \e[0;32mSYS\e[0m ][ $(date) \e[0;32m-\e[0m Uptime: $(uptime | awk '{print $3}') \e[0;32m-\e[0m $HOSTNAME \e[0;32m-\e[0m \e[1;33mSEL\e[0m ]" >> $MOTD
	else
		echo -e "[ \e[0;32mSYS\e[0m ][ $(date) \e[0;32m-\e[0m Uptime: $(uptime | awk '{print $3}') \e[0;32m-\e[0m $HOSTNAME \e[0;32m-\e[0 m\e[0;31mSEL\e[0m ]" >> $MOTD
fi

#Detect and monitor Internet availability:
CUR_HOUR=$(date +"%H")
echo -ne "\n" >> .gplog
if [ $CUR_HOUR = "00"  ]
	then
	rm .gplog
	echo -ne "\n" >> .gplog
fi


#Template for appending text to the end of a line by it's number
#awk -v OFS=" " 'NR == 1 { $(NF+1)="NO" };1' newfile > newerfile && cat newerfile > newfile && rm newerfile

#Check Internet Status by pinging 8.8.8.8, Google's Public DNS server that's only failed twice ever.
function CHECK_WAN {
GOOGLE_STATUS=$(ping -c4 8.8.8.8 | awk 'NR == 8 {print $6}' | cut -c1)
#echo $LAST_EXEC
if [ $GOOGLE_STATUS -eq 0 ]
	then
	INT_STATUS="true"
	INT_COL="\e[0;32mINT\e[0m"
	if [ $LAST_EXEC -gt 30 ]
		then
		echo "hello from if 1"
		awk -v OFS=" " 'NR == 1 { $(NF+1)="[0;32m$CUR_HOUR[0m" };1' .gplog > newerfile && cat newerfile > .gplog && rm newerfile
	fi
elif [ $GOOGLE_STATUS -lt 4 ]
	then
	INT_STATUS="false"
	INT_COL="\e[1;33mINT\e[0m"
	if [ $LAST_EXEC -gt 30 ]
		then
		echo "hello from if 2"
		awk -v OFS=" " 'NR == 1 { $(NF+1)="[1;33m$CUR_HOUR[0m" };1' .gplog > newerfile && cat newerfile > .gplog && rm newerfile
	fi
	else
	INT_STATUS="false"
	INT_COL="\e[0;31mINT\e[0m"
	if [ $LAST_EXEC -gt 30 ]
		then
		echo "hello from if 3"
		awk -v OFS=" " 'NR == 1 { $(NF+1)="[0;32m$CUR_HOUR[0m" };1' .gplog > newerfile && cat newerfile > .gplog && rm newerfile
	fi		
fi

sed -i "s/\$CUR_HOUR/$CUR_HOUR/g" .gplog
echo -e "[ $INT_COL ][ $(awk 'NR==1 {print}' .gplog) ]" >> $MOTD
}

#Calculates the system memory usage as a rounded integer percentage and prints to a log.
function CHECK_MEM {
CUR_MEM=$(free | awk 'NR == 2 {print $3} NR == 2 {print $2}' | paste -sd" " | awk 'NR == 1 {print $1/$2*100}' | awk '{printf("%d\n",$1 + 0.5)}')
if [ $CUR_MEM -lt 60 ]
	then
	CUR_MEM_COL="\e[0;32m"
	elif [ $CUR_MEM -ge 60 -a $CUR_MEM -lt 80 ]
	then
	CUR_MEM_COL="\e[1;33m"
	else
	CUR_MEM_COL="\e0;31m"
fi
	echo -e "[ $CUR_MEM_COL \bRAM\e[0m ][ $CUR_MEM_COL \b%$CUR_MEM\e[0m memory in use ]" >> $MOTD
}

#Check CPU usage, scale to multi-threaded systems
function CHECK_CPU {
CUR_CPU=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print $1}' | awk '{printf("%d\n",$1 + 0.5)}')
#Possibly the least elegant way to calculate average cpu usage and normalize to cpu core count:
#AVE_CPU=$(echo -e "$(echo -e "($(uptime | cut -d" " -f14) / $(cat /proc/cpuinfo | grep -c "processor")) * 100" | bc -l) / 1 " | bc)
CPU_AVE_LOAD_15=$(uptime | awk 'NF > 1 {print $NF}')
CPU_NUM_CORES=$(cat /proc/cpuinfo | grep -c "processor")
AVE_CPU=$(echo -e "$(echo -e "($CPU_AVE_LOAD_15 / $CPU_NUM_CORES) * 100" | bc -l) / 1 " | bc)
if [ $AVE_CPU -lt 60 ]
        then
	CPU_COL="\e[0;32m"
        elif [ $AVE_CPU -ge 60 -a $AVE_CPU -lt 80 ] -o [ $AVE_CPU -lt 80 ]
        then
	CPU_COL="\e[1;33m"
        else
	CPU_COL="\e[0;31m"
fi
	echo -e "[ $CPU_COL \bCPU\e[0m ][ $CPU_COL%$AVE_CPU\e[0m ave 15m ]" >> $MOTD
}

function CHECK_DISK {
CUR_DISK=$(df -h | awk 'NR == 2 {print $5}' | cut -c1,2)
FREEH=$(df -h | awk 'NR == 2 {print $4}')
if [ $CUR_DISK -lt 60 ]
	then
	DISK_COL="\e[0;32m"
	elif [ $CUR_DISK -ge 60 -a $CUR_DISK -lt 80 ] -o [ $CUR_DISK -lt 80 ]
	then
	DISK_COL="\e[1;33m"
	else
	DISK_COL="\e[0;31m"
fi
	echo -e "[ $DISK_COL \bDSK\e[0m ][ $DISK_COL%$CUR_DISK\e[0m, $FREEH free on primary disk ]" >> $MOTD
}

#Determine how many (if any) updates are available. Disabled because yum check-update is behaving oddly.

#function CHECK_YUM {
#if [ $INT_STATUS = "false" ]
#	then
#	echo -e "[ \e[0;31m$PACKAGE_MANAGER\e[0m ][ No connection to internet ]" >> $MOTD
#	else
#			yum check-update > .pmlog
#			if [ -z "$?" -o "$?" != "0" -a "$?" != "100" ]
#			then
#			echo -e "[ \e[0;31m$PACKAGE_MANAGER\e[0m ][ $PACKAGE_MANAGER exited with error code $? ]" >> $MOTD
#			else
#			NUM_UPDATES=$(grep -c "updates" .pmlog)
#			fi
#				if [ "$NUM_UPDATES" != "0" ]
#					then
#				echo -e "[ \e[1;33m$PACKAGE_MANAGER\e[0m ][ $NUM_UPDATES update(s) available ]" >> $MOTD
#					else
#				echo -e "[ \e[0;32m$PACKAGE_MANAGER\e[0m ][ $NUM_UPDATES updates available, System is up to date ]" >> $MOTD
#				fi
#fi
#}


#Execute and print output for all desired functions as by the user's configuration.
if [ $INTERNET = "true" ]; then	CHECK_WAN; fi
if [ $MEMORY = "true" ]; then CHECK_MEM; fi 
if [ $CPU = "true" ]; then CHECK_CPU; fi
if [ $DISK = "true" ]; then CHECK_DISK; fi
#if [ $UPDATES = "true" ] && [ $INTERNET = "true" ]; then CHECK_YUM; fi

cat $MOTD
exit 0
