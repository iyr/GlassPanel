#!/bin/bash

#Vanilla Console Resolution is 80 Columns by 22 Rows (mostly).

#Detect Initial Setup
USER=$(whoami)
PACKAGE_MANAGER="YUM"

MOTD="/tmp/.tmpmotd_$USER"

#Remove temporary motd, if one already exists.
if [ -f "$MOTD" ]
	then
	rm $MOTD
fi

if [ $USER = "root" ]
	then
		if [ -f "/root/.gpc_settings" ]
		then
			echo -e "Generic settings file found, configuring for root."
			mv /root/.gpc_settings /root/.gpc_settings_root
			SETTINGS="/root/.gpc_settings_root"
		else
			SETTINGS="/root/.gpc_settings_root"
		fi
	else
		if [ -f "/home/$USER/.gpc_settings" ]
		then
			echo -e "Generic settings file found, configuring for $USER \b."
			mv /home/$USER/.gpc_settings /home/$USER/.gpc_settings_$USER
			SETTINGS="/home/$USER/.gpc_settings_$USER"
		else
			SETTINGS="/home/$USER/.gpc_settings_$USER"
		fi
fi

if [ -f "$SETTINGS" ]
	then
		echo -e "Configuration file detected for $USER!"
		echo -e "Reading settings..."
		source $SETTINGS
	else
		echo -e "No configuration file found!"
		echo -e "Detecting system..."
		echo -e "Appending $USER's bash profile..."
		if [ $USER = "root" ]
			then
				sed -i '/cat \/tmp\/.tmpmotd_root/d' /root/.bash_profile
				echo -e "cat $MOTD" >> /root/.bash_profile
			else
				sed -i "/cat \/tmp\/.tmpmotd_$USER/d" /home/$USER/.bash_profile
				echo -e "cat $MOTD" >> /home/$USER/.bash_profile
		fi

		#Add GlassPanel to user's crontab
		#Method barrowed from http://stackoverflow.com/questions/878600
		crontab -l > tmpcron
		if [ $USER = "root" ]
			then
				echo -e "*/30 * * * * /root/gpc" >> tmpcron
			else
				echo -e "*/30 * * * * /home/$USER/gpc" >> tmpcron
		fi
		crontab tmpcron
		rm tmpcron

		echo -e "Generating settings file for $USER \b..."		
		#Generate Tweakable Settings file
		echo -e "USER=$USER" >> $SETTINGS
		echo -e "#Insert a custom static header to the Glass Panel, if desired:" >> $SETTINGS
		echo -e "HEADER=" >> $SETTINGS
		echo -e "#Append a custom static footer to the Glass Panel, if desired:" >> $SETTINGS
		echo -e "FOOTER=" >> $SETTINGS
		echo -e "#Decide what default aspects of the system GlassPanel should monitor and display:" >> $SETTINGS
		echo -e "INTERNET=true" >> $SETTINGS
		echo -e "MEMORY=true" >> $SETTINGS
		echo -e "CPU=true" >> $SETTINGS
		echo -e "SELINUX=true" >> $SETTINGS
		echo -e "UPDATES=true" >> $SETTINGS
		echo -e "#Adjust settings for color coding; below moderate is green, below critical is yellow and above is red" >> $SETTINGS
		echo -e "#Memory Settings:" >> $SETTINGS
		echo -e "MODERATE_MEM=60" >> $SETTINGS
		echo -e "CRITICAL_MEM=80" >> $SETTINGS
		echo -e "#CPU Settings:" >> $SETTINGS
		echo -e "MODERATE_CPU=60" >> $SETTINGS
		echo -e "CRITICAL_CPU=80" >> $SETTINGS
		echo -e "#Allows you to append the status of selected services to the motd (none enabled by default)" >> $SETTINGS
		echo -e "#Usage: SERVICE \"ServiceName\" \"ServiceAlias\" (no spaces in alias)" >> $SETTINGS
		echo -e "#Example: SERVICE NetworkManager Networking" >> $SETTINGS
		echo -e "#Allows you to append the status of selected websites to the motd (none enabled by default)" >> $SETTINGS
		echo -e "#Usage: WEBSITE \"URL\" \"WebsiteAlias\" (no spaces in alias)" >> $SETTINGS
		echo -e "#Example: WEBSITE google.com Google" >> $SETTINGS
		echo -e "#Environment Settings, do not edit." >> $SETTINGS
fi


#Print the status of a service:
#NM_STATUS=$(service NetworkManager status | awk 'NR == 3 {print $2}')
#if [ $NM_STATUS = "active" ]
#	then
#	echo -e "[ \e[0;32mNetworking\e[0m ]" >> $MOTD
#	else
#	echo -e "[ \e[0;31mNetworking\e[0m ]" >> $MOTD
#fi

#Display overall system information
echo -e "[ \e[0;32mSYS\e[0m ][ $(date) \e[0;32m-\e[0m Uptime: $(uptime | awk '{print $3}') \e[0;32m-\e[0m $HOSTNAME ]" >> $MOTD

#Calculate the amount of time that has elapsed since the last execution of the script
LAST_EXEC=$(echo -e "$(date | awk '{print $4}' | cut -d ':' -f2) - $(cat /tmp/.tmpmotd_iyr | awk 'NR == 1 {print $7}' | cut -d ':' -f2)" | bc)

#Detect and monitor Internet availability:
CUR_HOUR=$(date +"%H")
if [ $CUR_HOUR = "00" ]
	then rm .gplog; touch .gplog
fi

GOOGLE_STATUS=$(ping -c4 google.com | awk 'NR == 8 {print $6}' | cut -c1)
if [ $GOOGLE_STATUS -eq 0 ]
	then
	INT_STATUS="true"
	INT_COL="\e[0;32mINT\e[0m"
	if [ $LAST_EXEC -gt 30 ]
		then
		echo -ne "\e[0;32m$CUR_HOUR \e[0m" >> .gplog
	fi
	elif [ $GOOGLE_STATUS -gt 0 ]
		then
		INT_STATUS="false"
		INT_COL="\e[1;33mINT\e[0m"
		if [ $LAST_EXEC -gt 30 ]
			then
			echo -ne "\e[1;33m$CUR_HOUR \e[0m" >> .gplog
		fi
	else
	INT_STATUS="false"
	INT_COL="\e[0;31mINT\e[0m"
	if [ $LAST_EXEC -gt 30 ]
		then
		echo -ne "\e[0;32m$CUR_HOUR \e[0m" >> .gplog
	fi
fi

#echo -e "\e[37;45m$CUR_HOUR\e[0m"

if [ $INTERNET = "true" ]
	then
	echo -e "[ $INT_COL ][ $(cat .gplog)]" >> $MOTD
fi


#Calculates the system memory usage as a rounded integer percentage and prints to a log
CUR_MEM=$(free | awk 'NR == 3 {print $3} NR == 2 {print $2}' | paste -sd" " | awk 'NR ==1 {print $2/$1*100}' | awk '{printf("%d\n",$1 + 0.5)}')
if [ $CUR_MEM -lt 60 ]
	then
	CUR_MEM_COL="\e[0;32m"
	elif [ $CUR_MEM -ge $MODERATE_MEM -a $CUR_MEM -lt $CRITICAL_MEM ]
	then
	CUR_MEM_COL="\e[1;33m"
	else
	CUR_MEM_COL="\e0;31m"
fi

if [ $MEMORY = "true" ]
	then
	echo -e "[ $CUR_MEM_COL \bRAM\e[0m ][ $CUR_MEM_COL \b%$CUR_MEM\e[0m memory in use ]" >> $MOTD
fi


CUR_CPU=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print $1}' | awk '{printf("%d\n",$1 + 0.5)}')
#Possibly the least elegant way to calculate average cpu usage and normalize to cpu core count:
AVE_CPU=$(echo -e "$(echo -e "($(uptime | cut -d" " -f14) / $(cat /proc/cpuinfo | grep -c "processor")) * 100" | bc -l) / 1 " | bc)
if [ $CUR_CPU -lt $MODERATE_CPU ] && [ $AVE_CPU -lt $MODERATE_CPU ]
        then
	CPU_COL="\e[0;32m"
        elif [ $CUR_CPU -ge $MODERATE_CPU -a $CUR_CPU -lt $CRITICAL_CPU ] && [ $AVE_CPU -ge $MODERATE_CPU -o $AVE_CPU -lt $CRITICAL_CPU ]
        then
	CPU_COL="\e[1;33m"
        else
	CPU_COL="\e[0;31m"
fi

if [ $CPU = "true" ]
	then
	echo -e "[ $CPU_COL \bCPU\e[0m ][ $CPU_COL \b%$CUR_CPU\e[0m CPU in use, $CPU_COL%$AVE_CPU\e[0m ave 15m ]" >> $MOTD
fi


#Determine how many (if any) updates are available.
if [ $INT_STATUS = "false" ]
	then
	echo -e "[ \e[0;31m$PACKAGE_MANAGER\e[0m ][ No connection to internet ]" >> $MOTD
	else
		if [ $UPDATES = "true" ]
		then
			yum check-update > .pmlog
			if [ -z "$?" -o "$?" != "0" -a "$?" != "100" ]
			then
			echo -e "[ \e[0;31m$PACKAGE_MANAGER\e[0m ][ $PACKAGE_MANAGER exited with error code $? ]" >> $MOTD
			else
			NUM_UPDATES=$(grep -c "updates" .pmlog)
			fi
				if [ "$NUM_UPDATES" != "0" ]
				then
				echo -e "[ \e[1;33m$PACKAGE_MANAGER\e[0m ][ $NUM_UPDATES update(s) available ]" >> $MOTD
				else
				echo -e "[ \e[0;32m$PACKAGE_MANAGER\e[0m ][ $NUM_UPDATES updates available, System is up to date ]" >> $MOTD
			fi
			fi
fi

#Determine status of SELinux and display how many (if any) alerts there are:
#enforcing 	= green
#permissive 	= yellow
#disabled 	= red
SEL_STATUS=$(sestatus | awk 'NR == 5 {print $3}')
SEL_ALERTS=$(sealert -l* | grep -c "denied") 
if [ $SEL_ALERTS -eq 0 ]
	then
	SEL_ALERT_COL="\e[0;32m"
	else
	SEL_ALERT_COL="\e[0;31m"
fi

if [ $SELINUX = "true" ]
	then
	if [ $SEL_STATUS = "enforcing" ]
		then
		echo -e "[ \e[0;32mSEL\e[0m ][ $SEL_ALERT_COL$SEL_ALERTS alert(s)\e[0m ]" >> $MOTD
	elif [ $SEL_STATUS = "permissive" ]
		then
		echo -e "[ \e[1;33mSEL\e[0m ][ $SEL_ALERT_COL$SEL_ALERTS alert(s)\e[0m ]" >> $MOTD
	else
		echo -e "[ \e[0;31mSEL\e[0m ][ $SEL_ALERT_COL$SEL_ALERTS alert(s)\e[0m ]" >> $MOTD
	fi
fi
cat $MOTD
exit 0
